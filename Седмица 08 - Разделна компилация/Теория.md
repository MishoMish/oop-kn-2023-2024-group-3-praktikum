# Разделна компилация. Абстракция. Копиращ конструктор и оператор=

## Разделна компилация.

Една програма на С++ може да бъде разбита в множество файлове, които се **компилират независимо един от друг**, т.е. осъществява се **разделна компилация**. В резултат на компилацията се получават няколко **обектни файла** (файлове с разширение **.obj**). Изпълнимият код напрограмата (файл с разширение .ехе) се получава след свързване на обектните файлове (**Linking**).

За да се възполваме максимално от разделната компилация, разделяме класовете на **.h** и **.cpp** файлове. Навсякъде където ще работим с класа, ще включваме **само .h файла.** По този начин, ако променим реализацията на някоя от функциите на класа, ще се **прекомпилира само този файл**.

**Поддържането на голяма(дълга) програма в един изходен файл (например .cpp файл) има няколко недостатъка:**

1. Малка промяна в кода изисква прекомпилиране на цялата програма.

2. Повторното използване на част от програмата, например клас, в друга програма изисква рискова операция за копиране и поставяне. Декларацията на класа, всички реализации на матодите на класа и всички други зависимости трябва да бъдат локализирани, копирани и поставени в друг файл.

3. Няколко програмисти не могат да работят върху програмата едновременно.

Поради тези причини повечето програми са разделени на няколко изходни файла, всеки от които съдържа логически свързани декларации. Всеки изходен файл се компилира отделно, създавайки файл с инструкции на машинния език, наречен обектен файл (напр. .obj файл в Windows и DOS):

Програма наречена Linker свързва обектните файлове заедно в един изпълним файл. Линкерът е отговорен за асоциирането на всички препратки към име в един обектен файл с дефиницията на името, което може да бъде в друг обектен файл. Този процес се нарича разделяне на адреси. Понякога дефиницията на име не е в нито един от обектните файлове на проекта. В този случай линкерът търси стандартната библиотека на C++ и всякакви специални библиотеки, посочени от програмиста за дефиницията на името.

**Ако дефиницията на името все още не може да бъде намерена, линкерът генерира грешка:**
пример:

```
Linking...
main.obj : error LNK2001: unresolved external symbol "int __cdecl sine(int)" (?sine@@YAHH@Z)
Debug/Lab5b.exe : fatal error LNK1120: 1 unresolved externals
Error executing link.exe.
Lab5b.exe - 2 error(s), 0 warning(s)
```

**Header files:**

Програмите с множество изходни файлове звучат страхотно, но има проблем. Докато компилаторът е готов да приеме, че едно име може да се използва в изходния файл, без да е дефинирано там , компилаторът трябва поне да знае типа на името, за да изпълни type checking, variant selections, and offset calculations. Но компилаторът компилира само един файл в даден момент. Той не знае нищо за другите изходни файлове на проекта; не може да се очаква да търси типа на име по същия начин, по който линкерът търси дефиниция на име. За съжаление, задължение на програмиста е да постави декларации за типове на всички използвани, но недефинирани имена във файла.
За да се справим с този проблем трябва да декларираме променливите, функциите, класовете и тн. За тази цел използваме header файловете.
Header файловете са с разширение -( .h) / ( .hpp)
пример:

```
Library.h
```

В тях декларираме променливите, функциите, класовете и тн. които искаме да ползваме.
За да включим header файла към нашия cpp file използваме директивата #include.
#include взема името на даден файл като свой аргумент и се заменя с цялото съдържание на файла.

**Pragma once / Header guards :**

При използването на header файлове може да възникне следният проболем:
Многократно включване на един и същ header file.

```
H_file.h: // name of the file

#include<string>

void f(std::string& str)
{
    //...
}
```

task.cpp // name of the file

```
#include<string>
#include"H_file.h"   // inlude <string> multiple times

int main()
{
    strd::string str = "some text";
    f(str);
    return 0;
}
```

**include guards:**
Многократното включване се предотвратява с помощта на "include guards". Те се реализират с помощта на директивите #define, #ifndef, #endif на препроцесора.
пример:

```
// Box.h
#ifndef BOX_H
#define BOX_H

class Box    //  a class definition
{
};

#endif
```

Основното предимство на използването на "include guards" е, че те ще работят с всички съвместими със стандарт компилатори и препроцесори.

**pragma once:**

В езиците за програмиране C и C++ #pragma once е нестандартна, но широко поддържана директива за препроцесор, предназначена да накара текущия изходен файл да бъде включен само веднъж в една компилация.
По този начин, #pragma once служи за същата цел като #include guards, но с няколко предимства, включително: по-малко код, избягване на сблъсъци с имена и подобрена скорост на компилиране.
пример:

```
// Box.h
#pragma once

class Box
{
};
```
